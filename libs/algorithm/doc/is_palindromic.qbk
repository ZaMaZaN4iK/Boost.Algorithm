[/ File is_palindromic.qbk]

[section:is_palindromic is_palindromic]

[/license
Copyright (c) 2016 Alexander Zaitsev

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
]

The header file 'is_palindromic.hpp' contains four variants of a single algorithm, `is_palindromic`. The algorithm tests the sequence and returns true if the sequence is palindromic.

The routine `is_palindromic` takes a sequence and, optionally, a predicate. It will return true if the predicate returns true for tested elements by algorithm in the sequence. 

The routine come in 4 forms; the first one takes two iterators to define the range. The second form takes two iterators to define the range and a predicate. 
The third form takes a single range parameter, and uses Boost.Range to traverse it. And the fourth form takes a single range parameter ( uses Boost.Range to traverse it) and a predicate.


[heading interface]

The function `is_palindromic` returns true if the predicate returns true any tested by algorithm items in the sequence.  
There are four versions: 
1) takes two iterators.
2) takes two iterators and a predicate.
3) takes a range.
4) takes a range and a predicate.

``
template<typename BidirectionalIterator>
	bool is_palindromic ( BidirectionalIterator begin, BidirectionalIterator end );
template<typename BidirectionalIterator, typename Predicate>
	bool is_palindromic ( BidirectionalIterator begin, BidirectionalIterator end, Predicate p );
template<typename Range> 
	bool is_palindromic ( const Range &r );
template<typename Range, typename Predicate> 
	bool is_palindromic ( const Range &r, Predicate p );
``


[heading Examples]

Given the containers: 
const std::list<int> empty,
const std::vector<char> singleElement{'z'},
int oddNonPalindromic[] = {3,2,2},
const int evenPalindromic[] = {1,2,2,1}, then
``

is_palindromic(empty))  --> true //empty range                                                                       
is_palindromic(singleElement))  --> true                                                               
is_palindromic(std::begin(oddNonPalindromic), std::end(oddNonPalindromic))) --> false                    
is_palindromic(std::begin(evenPalindromic), std::end(evenPalindromic))) --> true                                                                                                                                                                                                            
is_palindromic(empty.begin(), empty.end(), functorComparator())) --> true //empty range                             
is_palindromic(std::begin(oddNonPalindromic), std::end(oddNonPalindromic), funcComparator<int>)) --> false
is_palindromic(evenPalindromic, std::equal_to<int>())) --> true                                          
``

[heading Iterator Requirements]

`is_palindromic` work on Bidirectional and RandomAccess iterators.

[heading Complexity]

All of the variants of `is_palindromic` run in ['O(N)] (linear) time; that is, they compare against each element in the list once. If any of the comparisons not succeed, the algorithm will terminate immediately, without examining the remaining members of the sequence.

[heading Exception Safety]

All of the variants of `is_palindromic` take their parameters by value or const reference, and do not depend upon any global state. Therefore, all the routines in this file provide the strong exception guarantee.

[heading Notes]

* `is_palindromic` returns true for empty ranges and for single element ranges. 

* If you use version of 'is_palindromic' without custom predicate, 'is_palindromic' uses default 'operator==' for elements. If you want use custom predicate, you must redefine 'operator=='.

[endsect]

[/ File is_palindromic.qbk
Copyright 2016 Alexander Zaitsev
Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt).
]
