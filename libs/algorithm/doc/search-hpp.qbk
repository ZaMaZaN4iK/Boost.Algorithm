[/ QuickBook Document version 1.5 ]

[section:search file 'search.hpp']

[/license

Copyright (c) 2010 Marshall Clow

Distributed under the Boost Software License, Version 1.0.
(See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)

]


[heading Overview]

The header file 'search.hpp' contains a series of algorithms for searching 
sequences of values. These are classic algorithms in computer science, and have much better performance than "naive" searches.

Nomenclature: for each of these searches, I refer to the sequence being searched for as the "pattern", and the sequence being searched in as the "corpus".

Each of the functions is passed two pairs of iterators. The first two define the corpus and the second two define the pattern. Note that the two pairs need not be of the same type, but they do need to "point" at the same type. In other words, I1::value_type and I2::value_type need to be the same type.

The return value of the function is an iterator pointing to the start of the pattern in the corpus. If the pattern is not found, it returns the end of the corpus ('corpus_last').

Each search takes an (optional) comparison predicate.
The predicate should have the form of:

``
bool (*comp) ( const I1::value_type &one, const I2::value_type &two );
``

where I1 and I2 are the iterator types passed to the search function. Of course, the predicate can be a free function, a Boost.Bind expression, a functor, or even (in C++0x) a lambda expression.

The general rule for such a predicate is:

For each item 'p' in the pattern, the predicate should return true for at most one item in the corpus.


[heading Boyer-Moore]

The Boyerâ€“Moore string search algorithm is a particularly efficient string searching algorithm, and it has been the standard benchmark for the practical string search literature.

It was developed by Bob Boyer and J Strother Moore in 1977. The algorithm preprocesses the target string (pattern) that is being searched for. The execution time of the Boyer-Moore algorithm, while still linear in the size of the string being searched, can have a significantly lower constant factor than many other search algorithms: it doesn't need to check every character of the string to be searched, but rather skips over some of them. Generally the algorithm gets faster as the key being searched for becomes longer. Its efficiency derives from the fact that with each unsuccessful attempt to find a match between the search string and the text it's searching, it uses the information gained from that attempt to rule out as many positions of the text as possible where the string cannot match.

``
template <typename I1, typename I2>
I2 boyer_moore_search ( I1 corpus_first, I1 corpus_last, I2 pat_first, I2 pat_last );

template <typename I1, typename I2, typename Pred>
I2 boyer_moore_search ( I1 corpus_first, I1 corpus_last, I2 pat_first, I2 pat_last, Pred p );
``

Memory Use: The algorithm allocates two internal tables. The first one is proportional to the length of the pattern; the second one has one entry for each member of the "alphabet" in the pattern. For (8-bit) character types, this table contains 256 entries.

Complexity:	The worst-case performance to find a pattern in the corpus is linear; that is, proportional to the length of the corpus being searched. In general, the search is sub-linear; not every character need be checked.


[heading Boyer-Moore-Horspool]

The Boyer-Moore-Horspool search algorithm was published by Nigel Horspool in 1980. It is a refinement of the Boyer-Moore algorithm that trades space for time. It uses less space for internal tables than Boyer-Moore, and has poorer worst-case performance.

``
template <typename I1, typename I2>
I2 boyer_moore_horspool_search ( I1 corpus_first, I1 corpus_last, I2 pat_first, I2 pat_last );

template <typename I1, typename I2, typename Pred>
I2 boyer_moore_horspool_search ( I1 corpus_first, I1 corpus_last, I2 pat_first, I2 pat_last, Pred p );
``

Memory Use: The algorithm an internal table that has one entry for each member of the "alphabet" in the pattern. For (8-bit) character types, this table contains 256 entries.

Complexity: The worst-case performance is O(m x n), where m is the length of the pattern and n is the length of the corpus. The average time is O(n). The best case performance is sub-linear, and is, in fact, identical to Boyer-Moore, but the initialization is quicker and the internal loop is simpler than Boyer-Moore.


[heading Knuth-Morris-Pratt]

The Knuth-Morris-Pratt algorithm was developed by Donald Knuth and Vaughan Pratt, and independently by James H. Morris in 1977, and then published jointly.

The core idea of the Knuth-Morris-Pratt algorithm is that when a comparision of the pattern against a section of the corpus fails, the failure contains information that can be used to decide where to start looking for the match - instead of just at the next entry in the corpus.

``
template <typename I1, typename I2>
I2 knuth_morris_pratt_search ( I1 corpus_first, I1 corpus_last, I2 pat_first, I2 pat_last );

template <typename I1, typename I2, typename Pred>
I2 knuth_morris_pratt_search ( I1 corpus_first, I1 corpus_last, I2 pat_first, I2 pat_last, Pred p );
``

Memory Use: The algorithm uses an internal table that contains one entry for each entry in the pattern.

Complexity: The performance is O(m + n), where m is the length of the pattern and n is the length of the corpus.
	
[endsect]
